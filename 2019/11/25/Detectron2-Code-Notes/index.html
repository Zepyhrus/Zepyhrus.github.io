<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="Detectron 2 源码阅读笔记 Most part of the begining of this notes is inherited from https://www.cnblogs.com/marsggbo/p/11677086.html.  1. 代码结构概览 核心部分  configs: 储存各种网络的yaml配置文件； datasets: 存放数据集的地方； deteectron">
<meta property="og:type" content="article">
<meta property="og:title" content="Detectron2: Code Notes">
<meta property="og:url" content="http://yoursite.com/2019/11/25/Detectron2-Code-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Detectron 2 源码阅读笔记 Most part of the begining of this notes is inherited from https://www.cnblogs.com/marsggbo/p/11677086.html.  1. 代码结构概览 核心部分  configs: 储存各种网络的yaml配置文件； datasets: 存放数据集的地方； deteectron">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/home/ubuntu/Workspace/detectron2/materials/ggbjq2bbwo.png">
<meta property="og:image" content="http://yoursite.com/home/ubuntu/Workspace/detectron2/materials/0y66sksfp3.png">
<meta property="og:image" content="http://yoursite.com/home/ubuntu/Workspace/detectron2/materials/hpnl6x7tcn.png">
<meta property="og:updated_time" content="2020-01-03T09:48:26.681Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Detectron2: Code Notes">
<meta name="twitter:description" content="Detectron 2 源码阅读笔记 Most part of the begining of this notes is inherited from https://www.cnblogs.com/marsggbo/p/11677086.html.  1. 代码结构概览 核心部分  configs: 储存各种网络的yaml配置文件； datasets: 存放数据集的地方； deteectron">
<meta name="twitter:image" content="http://yoursite.com/home/ubuntu/Workspace/detectron2/materials/ggbjq2bbwo.png">
  <link rel="canonical" href="http://yoursite.com/2019/11/25/Detectron2-Code-Notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Detectron2: Code Notes | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/Detectron2-Code-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zepyhrus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Detectron2: Code Notes

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-25 10:55:31" itemprop="dateCreated datePublished" datetime="2019-11-25T10:55:31+08:00">2019-11-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-03 17:48:26" itemprop="dateModified" datetime="2020-01-03T17:48:26+08:00">2020-01-03</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Detectron 2 源码阅读笔记</strong></p>
<p>Most part of the begining of this notes is inherited from <a href="https://www.cnblogs.com/marsggbo/p/11677086.html" target="_blank" rel="noopener">https://www.cnblogs.com/marsggbo/p/11677086.html</a>. </p>
<h1 id="1-代码结构概览"><a href="#1-代码结构概览" class="headerlink" title="1. 代码结构概览"></a>1. 代码结构概览</h1><ol>
<li><p>核心部分</p>
<ul>
<li>configs: 储存各种网络的yaml配置文件；</li>
<li>datasets: 存放数据集的地方；</li>
<li>deteectron2：运行代码的核心组建；</li>
<li>tools：提供了运行代码的入口以及一切可视化的代码问价。</li>
</ul>
</li>
<li><p>Tutorial部分</p>
<ul>
<li>demo：demo；</li>
<li>docs：docs；</li>
<li>tests：tests；</li>
<li>projects：提供了真实的项目代码示例；</li>
</ul>
</li>
</ol>
<h1 id="2-代码逻辑分析"><a href="#2-代码逻辑分析" class="headerlink" title="2. 代码逻辑分析"></a>2. 代码逻辑分析</h1><h2 id="2-1-超参数配置"><a href="#2-1-超参数配置" class="headerlink" title="2.1 超参数配置"></a>2.1 超参数配置</h2><p>Detectron2中的参数配置使用了yacs这个库，这个库能够很好地重用和拼接超参数文件配置。我们先看一下<code>detrctron2/config/</code>的文件结构：</p>
<ul>
<li>compat.py: 应该是对之前的Detectron库的兼容吧，可忽略。</li>
<li>config.py: 定义了一个<code>CfgNode</code>类，这个类继承自<code>fvcore</code>库(fb写的一个共公共库，提供一些共享的函数，方便各种不同项目使用)中定义的<code>CfgNode</code>,总之就是不断继承。。。继承关系是这样的：<code>detrctron2.config.CfgNode-&gt;fcvore.common.config.CfgNode-&gt;yacs.config.CfgNode-&gt;dict</code>。另外该文件还提供了<code>get_cfg()</code>方法，该方法会返回一个含有默认配置的<code>CfgNode</code>,而这些默认的配置值在下面的<code>default.py</code>中定义了，之所以这样做是因为要配置的默认值太多了，所以为了文档清晰才写到了一个新的文件中去，不过，yacs库的作者也建议这样做。</li>
<li>default.py: 如上面所说，该文件定义了各种参数的默认值。</li>
</ul>
<p>了解配置函数的方法后我们再回到<code>tools/train_net.py</code>，我们一行一行的来理解。</p>
<ul>
<li><code>tools/train_net.py</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.config <span class="keyword">import</span> get_cfg</span><br><span class="line"><span class="keyword">from</span> detectron2.engine <span class="keyword">import</span> DefaultTrainer, default_argument_parser, default_setup, hooks, launch</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create configs and perform basic setups.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cfg = get_cfg() </span><br><span class="line">    cfg.merge_from_file(args.config_file) </span><br><span class="line">    cfg.merge_from_list(args.opts)</span><br><span class="line">    cfg.freeze()</span><br><span class="line">    default_setup(cfg, args)</span><br><span class="line">    <span class="keyword">return</span> cfg</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cfg = get_cfg()</code>： 获取已经配置好默认参数的cfg</li>
<li><code>cfg.merge_from_file(args.config_file)</code>：<code>config_file</code>是指定的yaml配置文件，通过<code>merge_from_file</code>这个函数会将yaml文件中指定的超参数对默认值进行覆盖。</li>
<li><code>cfg.merge_from_list(args.opts)</code>：<code>merge_from_list</code>作用同上面的类似，只不过是通过命令行的方式覆盖。</li>
<li><code>cfg.freeze()</code>: <code>freeze</code>函数的作用是将超参数值冻结，避免被程序不小心修改。</li>
<li><code>default_setup(cfg, args)</code>：<code>default_setup</code>是<code>detectron2/engine/default.py</code>中提供的一个默认配置函数，具体是怎么配置的这里不详细说明了。不过需要知道的值这个文件中还提供了很多其他的配置函数，例如还提供了两个类：<code>DefaultPredictor</code>和<code>DefaultTrainer</code>。</li>
</ul>
<h2 id="2-2-Trainer结构"><a href="#2-2-Trainer结构" class="headerlink" title="2.2 Trainer结构"></a>2.2 Trainer结构</h2><p>既然上面提到了<code>DefaultTrainer</code>，那么我们就从这个类入手了解一下<code>detectron2.engine</code>,其代码结构如下：</p>
<ul>
<li><p><code>train_loop.py</code>：这个函数主要作用是提供了三个重要的类：</p>
<ul>
<li><code>HookBase</code>: 这是一个Hook的基类，用于指定在训练前后或者每一个step前后需要做什么事情，所以根据特定的需求需要对如下四种方法做不同的定义：<code>before_train</code>, <code>after_train</code>, <code>before_step</code>, <code>after_step</code>。以<code>before_step</code>。</li>
<li><code>TrainerBase</code>: 该类中定义的函数可以归纳成三种，并初始化<code>_hooks</code>为<code>[]</code>：<ul>
<li><code>register_hooks</code>:这个很好理解，就是将用户定义的一些<code>hooks</code>进行注册，<strong>说大白话就是把若干个<code>Hook</code>放在一个<code>list</code>里面去</strong>。之后只需要遍历这个<code>list</code>依次执行就可以了。<ul>
<li><code>register_hooks(hooks)</code>会将输入的<code>hooks</code>中的<code>trainer</code>设置为当前的类实例的弱引用，并将其添加到当前类实例的<code>self._hooks</code>中去；</li>
</ul>
</li>
<li>第二类其实就是上面提到的遍历<code>hook list</code>并执行<code>hook</code>，不过这个遍历有四种，分别是<code>before_train</code>,<code>after_train</code>,<code>before_step</code>,<code>after_step</code>。还有一个就是<code>run_step</code>,这个函数其实就是平常我们在编写训练过程的代码，例如读数据，训练模型，获取损失值，求导数，反向梯度更新等,只不过在这个类里面没有定义。</li>
<li>第三类就是<code>train</code>函数，它有两个参数，分别是开始的迭代数和最大的迭代数。之后就是重复依次执行第二类中的函数指定迭代次数。</li>
</ul>
</li>
<li><code>SimpleTrainer</code>:其实就是继承自<code>TrainerBase</code>,然后定义了<code>run_step</code>等方法。我们后面也可以继承这个类做进一步的自定义。<ul>
<li>初始化基类，并赋予其<code>model</code>、<code>data_loader</code>、<code>_data_loader_iter</code>、<code>optimizer</code>；</li>
<li>这在随后的训练过程中会被继承为默认的训练类<code>DefaultTrainer</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>defaults.py</code>: 上面已介绍，提供了两个类：<code>DefaultPredictor</code>和<code>DefaultTrainer</code>，这个<code>DefaultTrainer</code>就继承自<code>SimpleTrainer</code>,所以存在如下继承关系：<code>detectron2.engine.default.DefaultTrainer-&gt;detectron2.engine.train_loop.SimpleTrainer-&gt;detectron2.engine.train_loop.TrainerBase</code></p>
</li>
<li><p><code>hooks.py</code>:定义了很多继承自<code>train_loop.HookBase的Hook</code>。</p>
<ul>
<li><code>CallBackHook</code>: Create a hook using callback functions provided by the user.</li>
<li><code>IterationTimer</code>：Track the time spent for each iteration (each run_step call in the trainer). Print a summary in the end of training.；</li>
<li><code>PeriodicWriter</code>：Write events to EventStorage periodically.</li>
<li><code>PeriodicCheckpointer</code>：Same as :class:<code>detectron2.checkpoint.PeriodicCheckpointer</code>, but as a hook.</li>
<li><code>LRScheduler</code>：A hook which executes a torch builtin LR scheduler and summarizes the LR. It is executed after every iteration.</li>
<li><code>AutogradProfiler</code>：A hook which runs <code>torch.autograd.profiler.profile</code>.</li>
<li><code>EvalHook</code>: Run an evaluation function periodically, and at the end of training.</li>
<li><code>PreciseBN</code>: The standard implementation of BatchNorm uses EMA in inference, which is sometimes suboptimal. This class computes the true average of statistics rather than the moving average, and put true averages to every BN layer in the given model.</li>
</ul>
</li>
<li><p><code>launch.py</code>: 前面提到过，可以理解成代码启动器，可以根据命令决定是否采用分布式训练（或者单机多卡）或者单机单卡训练。</p>
</li>
</ul>
<p>整个训练过程按照如下流程进行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.before_train()</span><br><span class="line"><span class="keyword">for</span> self.iter <span class="keyword">in</span> range(start_iter, max_iter):</span><br><span class="line">  self.before_step()</span><br><span class="line">  self.run_step()</span><br><span class="line">  self.after_step()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  self.after_train()</span><br></pre></td></tr></table></figure>

<p>小结：<br><img src="/home/ubuntu/Workspace/detectron2/materials/ggbjq2bbwo.png" alt="fig-1"></p>
<h2 id="2-3-Trainer解析"><a href="#2-3-Trainer解析" class="headerlink" title="2.3 Trainer解析"></a>2.3 Trainer解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(args)</span>:</span></span><br><span class="line">    cfg = setup(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.eval_only:</span><br><span class="line">        ...</span><br><span class="line">    trainer = Trainer(cfg)</span><br><span class="line">    trainer.resume_or_load(resume=args.resume)</span><br><span class="line">    <span class="keyword">if</span> cfg.TEST.AUG.ENABLED:</span><br><span class="line">        trainer.register_hooks(</span><br><span class="line">            [hooks.EvalHook(<span class="number">0</span>, <span class="keyword">lambda</span>: trainer.test_with_TTA(cfg, trainer.model))]</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> trainer.train()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-build-方法"><a href="#2-3-1-build-方法" class="headerlink" title="2.3.1 build_*方法"></a>2.3.1 build_*方法</h3><p><code>build_*</code>主要来自于<code>engine.defaults.DefaultTrainer</code>类，继承自<code>engine.train_loop.SimpleTrainer</code>类。而<code>detectron2.engine.default.DefaultTrainer</code>在其<code>__init__(self, cfg)</code>函数中定义了解析cfg。如下面代码所示，cfg会作为参数倍若干个<code>build_*</code>方法解析，得到解析后的<code>model,optimizer</code>,<code>data_loader</code>等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.modeling <span class="keyword">import</span> build_model</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTrainer</span><span class="params">(SimpleTrainer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cfg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        cfg (CfgNode):</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Assume these objects must be constructed in this order.</span></span><br><span class="line">    model = self.build_model(cfg)</span><br><span class="line">    optimizer = self.build_optimizer(cfg, model)</span><br><span class="line">    data_loader = self.build_train_loader(cfg)</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    self.register_hooks(self.build_hooks())</span><br><span class="line">      </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_model</span><span class="params">(cls, cfg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        torch.nn.Module:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = build_model(cfg)</span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    logger.info(<span class="string">"Model:\n&#123;&#125;"</span>.format(model))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>下面我们以<code>DefaultTrainer.build_model</code>为例来介绍注册机制,该方法调用了<code>detectron2/modeling/meta_arch/build.py</code>的<code>build_model</code>函数,其源代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.utils.registry <span class="keyword">import</span> Registry</span><br><span class="line"></span><br><span class="line">META_ARCH_REGISTRY = Registry(<span class="string">"META_ARCH"</span>)</span><br><span class="line">META_ARCH_REGISTRY.__doc__ = <span class="string">"""..."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span><span class="params">(cfg)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Built the whole model, defined by `cfg.MODEL.META_ARCHITECTURE`.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  meta_arch = cfg.MODEL.META_ARCHITECTURE</span><br><span class="line">  <span class="keyword">return</span> META_ARCH_REGISTRY.get(meta_arch)(cfg)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>meta_arch = cfg.MODEL.META_ARCHITECTURE</code>： 根据超参数获得网络结构的名字</li>
<li><code>return META_ARCH_REGISTRY.get(meta_arch)(cfg)</code>：<code>META_ARCH_REGISTRY</code>是一个<code>Registry</code>类(这个在后面会详细介绍)，可以将这一行代码拆成如下几个步骤：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = META_ARCH_REGISTRY.get(meta_arch)</span><br><span class="line"><span class="keyword">return</span> model(cfg)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-注册机制Registry"><a href="#2-3-2-注册机制Registry" class="headerlink" title="2.3.2 注册机制Registry"></a>2.3.2 注册机制Registry</h3><p>假如你想自己实现一个新的backbone网络，那么你可以这样做:</p>
<p>首先在detectron2中定义好如下（实际上已经定义了）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron2/modeling/backbone/build.py</span></span><br><span class="line"></span><br><span class="line">BACKBONE_REGISTRY = Registry(<span class="string">'BACKBONE'</span>)</span><br></pre></td></tr></table></figure>

<p>之后在你创建的新的文件下按如下方式创建你的backbone</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># detectron2/modeling/backbone/your_backbone.py</span></span><br><span class="line"><span class="keyword">from</span> .build <span class="keyword">import</span> BACKBONE_REGISTRY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="meta">@BACKBONE_REGISTRY.register()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBackbone</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBackbone</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">BACKBONE_REGISTRY.register(MyBackbone)</span><br></pre></td></tr></table></figure>

<p><code>Registry</code>源代码如下（有删减）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Registry</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self._name = name</span><br><span class="line">    self._obj_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_do_register</span><span class="params">(self, name, obj)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> (</span><br><span class="line">      name <span class="keyword">not</span> <span class="keyword">in</span> self._obj_map</span><br><span class="line">    ), <span class="string">"An object named '&#123;&#125;' was already registered in '&#123;&#125;' registry!"</span>.format(name, self._name)</span><br><span class="line">    self._obj_map[name] = obj</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="comment"># used as a decorator</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func_or_class)</span>:</span></span><br><span class="line">        name = func_or_class.__name__</span><br><span class="line">        self._do_register(name, func_or_class)</span><br><span class="line">        <span class="keyword">return</span> func_or_class</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line">    <span class="comment"># used as a function call</span></span><br><span class="line">    name = obj.__name__</span><br><span class="line">    self._do_register(name, obj)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    ret = self._obj_map.get(name)</span><br><span class="line">    <span class="keyword">if</span> ret <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">raise</span> KeyError(<span class="string">"No object named '&#123;&#125;' found in '&#123;&#125;' registry!"</span>.format(name, self._name))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<ul>
<li>首先是<code>__init__</code>部分：<ul>
<li><code>self._name</code>则是你要注册的名字，例如对于完整的模型而言，<code>name</code>一般取<code>META_ARCH</code>。当然如果你需要自定义<code>backbone</code>网络，你也可以定义一个<code>Registry(&#39;BACKBONE&#39;)</code>;</li>
<li><code>self._obj_map</code>:其实就是一个字典。以模型为例，<code>key</code>就是你的模型名字，而<code>value</code>就是对应的模型类。这样你在传参时只需要修改一下模型名字就能使用不同的模型了。具体实现方法就是后面这几个函数;</li>
</ul>
</li>
<li><code>register</code>: 可以看到该方法定义了注册的两种方式，一种是当<code>obj==None</code>的时候，使用装饰器的方式注册，另外一种就是直接将obj作为参数调用<code>_do_register</code>进行注册。</li>
<li><code>_do_register</code>:真正注册的函数，可以看到它首先会判断name是否已经存在于<code>self._obj_map</code>了。什么意思呢？还是以backbone为例，我们定义了一个<code>BACKBONE_REGISTRY = Registry(&#39;BACKBONE&#39;)</code>,然后又定义了很多种<code>backbone</code>，而这些<code>backbone</code>都使用<code>@BACKBONE_REGISTRY.register()</code>的方式注册到了<code>BACKBONE_REGISTRY._obj_map</code>中了,所以才取名为<code>Registry</code>。</li>
</ul>
<h2 id="2-4-Detectron2-整体代码框架"><a href="#2-4-Detectron2-整体代码框架" class="headerlink" title="2.4 Detectron2 整体代码框架"></a>2.4 Detectron2 整体代码框架</h2><p>整体框架如下图所示：</p>
<p><img src="/home/ubuntu/Workspace/detectron2/materials/0y66sksfp3.png" alt="fig-2"></p>
<h1 id="3-Dataset"><a href="#3-Dataset" class="headerlink" title="3. Dataset"></a>3. Dataset</h1><p><strong>构建<code>data_loader</code>原理步骤</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># engine/default.py</span></span><br><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> (</span><br><span class="line">  MetadataCatalog,</span><br><span class="line">  build_detection_test_loader,</span><br><span class="line">  build_detection_train_loader,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTrainer</span><span class="params">(SimpleTrainer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cfg)</span>:</span></span><br><span class="line">    <span class="comment"># Assume these objects must be constructed in this order.</span></span><br><span class="line">    data_loader = self.build_train_loader(cfg)</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">build_train_loader</span><span class="params">(cls, cfg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      iterable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> build_detection_train_loader(cfg)</span><br></pre></td></tr></table></figure>

<p>函数调用关系如下图：</p>
<p><img src="/home/ubuntu/Workspace/detectron2/materials/hpnl6x7tcn.png" alt="fig-3"></p>
<p>结合前面两篇文章的内容可以看到<code>detectron2</code>在构建<code>model,optimizer</code>和<code>data_loader</code>的时候都是在对应的<code>build.py</code>文件里实现的。我们看一下<code>build_detection_train_loader</code>是如何定义的(对应上图中紫色方框内的部分(自下往上的顺序)）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_detection_train_loader</span><span class="params">(cfg, mapper=None)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A data loader is created by the following steps:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  1. Use the dataset names in config to query :class:`DatasetCatalog`, and obtain a list of dicts.</span></span><br><span class="line"><span class="string">  2. Start workers to work on the dicts. Each worker will:</span></span><br><span class="line"><span class="string">    * Map each metadata dict into another format to be consumed by the model.</span></span><br><span class="line"><span class="string">    * Batch them by simply putting dicts into a list.</span></span><br><span class="line"><span class="string">  The batched ``list[mapped_dict]`` is what this dataloader will return.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    cfg (CfgNode): the config</span></span><br><span class="line"><span class="string">    mapper (callable): a callable which takes a sample (dict) from dataset and</span></span><br><span class="line"><span class="string">      returns the format to be consumed by the model.</span></span><br><span class="line"><span class="string">      By default it will be `DatasetMapper(cfg, True)`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    a torch DataLoader object</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"><span class="comment"># 1. 获得dataset_dicts</span></span><br><span class="line">  dataset_dicts = get_detection_dataset_dicts(</span><br><span class="line">    cfg.DATASETS.TRAIN,</span><br><span class="line">    filter_empty=<span class="literal">True</span>,</span><br><span class="line">    min_keypoints=cfg.MODEL.ROI_KEYPOINT_HEAD.MIN_KEYPOINTS_PER_IMAGE</span><br><span class="line">    <span class="keyword">if</span> cfg.MODEL.KEYPOINT_ON</span><br><span class="line">    <span class="keyword">else</span> <span class="number">0</span>,</span><br><span class="line">    proposal_files=cfg.DATASETS.PROPOSAL_FILES_TRAIN <span class="keyword">if</span> cfg.MODEL.LOAD_PROPOSALS <span class="keyword">else</span> <span class="literal">None</span>,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将dataset_dicts转化成torch.utils.data.Dataset</span></span><br><span class="line">  dataset = DatasetFromList(dataset_dicts, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 进一步转化成MapDataset，每次读取数据时都会调用mapper来对dict进行解析</span></span><br><span class="line">  <span class="keyword">if</span> mapper <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    mapper = DatasetMapper(cfg, <span class="literal">True</span>)</span><br><span class="line">  dataset = MapDataset(dataset, mapper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 采样器</span></span><br><span class="line">  sampler_name = cfg.DATALOADER.SAMPLER_TRAIN</span><br><span class="line">  <span class="keyword">if</span> sampler_name == <span class="string">"TrainingSampler"</span>:</span><br><span class="line">    sampler = samplers.TrainingSampler(len(dataset))</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  batch_sampler = build_batch_data_sampler(</span><br><span class="line">    sampler, images_per_worker, group_bin_edges, aspect_ratios</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 数据迭代器 data_loader</span></span><br><span class="line">  data_loader = torch.utils.data.DataLoader(</span><br><span class="line">    dataset,</span><br><span class="line">    num_workers=cfg.DATALOADER.NUM_WORKERS,</span><br><span class="line">    batch_sampler=batch_sampler,</span><br><span class="line">    collate_fn=trivial_batch_collator,</span><br><span class="line">    worker_init_fn=worker_init_reset_seed,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data_loader</span><br></pre></td></tr></table></figure>

<p>后面的采样器和data_loader可以参阅<a href="https://www.cnblogs.com/marsggbo/p/11308889.html" target="_blank" rel="noopener">https://www.cnblogs.com/marsggbo/p/11308889.html</a>一文弄懂Pytorch的DataLoader, DataSet, Sampler之间的关系。</p>
<h2 id="3-1-获取dataset-dicts"><a href="#3-1-获取dataset-dicts" class="headerlink" title="3.1 获取dataset_dicts"></a>3.1 获取<code>dataset_dicts</code></h2><p><code>get_detection_dataset_dicts(dataset_names)</code>函数需要传递的一个重要参数是<code>dataset_names</code>,这个参数其实就是一个字符串，用来指定数据集的名称。通过这个字符串，该函数会调用<code>data/catalog.py</code>的<code>DatasetCatalog</code>类来进行解析得到一个包含数据信息的字典。</p>
<p>解析的原理是：<code>DatasetCatalog</code>有一个字典<code>_REGISTERED</code>，默认已经注册好了例如<code>coco</code>, <code>voc</code>这些数据集的信息。如果你想要使用你自己的数据集，那么你需要在最开始前你需要定义你的数据集名字以及定义一个函数(这个函数不需要传参，而且最后会返回一个<code>dict</code>，该<code>dict</code>包含你的数据集信息)，举个栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> DatasetCatalog</span><br><span class="line">my_dataset_name = <span class="string">'apple'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dicts</span><span class="params">()</span>:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> dict</span><br><span class="line"></span><br><span class="line">DatasetCatalog.register(my_dataset_name, get_dicts)</span><br></pre></td></tr></table></figure>

<p>当然，如果你的数据集已经是COCO的格式了，那么你也可以使用如下方法进行注册：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.data.datasets <span class="keyword">import</span> register_coco_instances</span><br><span class="line">my_dataset_name = <span class="string">'apple'</span></span><br><span class="line">register_coco_instances(my_dataset_name, &#123;&#125;, <span class="string">"json_annotation.json"</span>, <span class="string">"path/to/image/dir"</span>)</span><br></pre></td></tr></table></figure>

<p>最后，<code>get_detection_dataset_dicts</code>会返回一个包含若干个<code>dict</code>的<code>list</code>，之所以是<code>lis</code>t是因为参数<code>dataset_names</code>也是一个<code>list</code>，这样我们就可以制定多个<code>names</code>来同时对数据进行读取。</p>
<h2 id="3-2-解析成DatasetFromList"><a href="#3-2-解析成DatasetFromList" class="headerlink" title="3.2 解析成DatasetFromList"></a>3.2 解析成<code>DatasetFromList</code></h2><p><code>DatasetFromList(dataset_dict)</code>函数定义在<code>detectron2/data/common.py</code>中，它其实就是一个<code>torch.utils.data.Dataset</code>类，其源码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatasetFromList</span><span class="params">(data.Dataset)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Wrap a list to a torch Dataset. It produces elements of the list as data.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lst: list, copy: bool = True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      lst (list): a list which contains elements to produce.</span></span><br><span class="line"><span class="string">      copy (bool): whether to deepcopy the element when producing it,</span></span><br><span class="line"><span class="string">        so that the result can be modified in place without affecting the</span></span><br><span class="line"><span class="string">        source in the list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._lst = lst</span><br><span class="line">    self._copy = copy</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self._lst)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._copy:</span><br><span class="line">      <span class="keyword">return</span> copy.deepcopy(self._lst[idx])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> self._lst[idx]</span><br></pre></td></tr></table></figure>

<h3 id="3-3-将DatasetFromList转化为MapDataset"><a href="#3-3-将DatasetFromList转化为MapDataset" class="headerlink" title="3.3 将DatasetFromList转化为MapDataset"></a>3.3 将<code>DatasetFromList</code>转化为<code>MapDataset</code></h3><p>其实<code>DatsetFromList</code>和<code>MapDatase</code>t都是<code>torch.utils.data.Dataset</code>的子类，那他们的区别是什么呢？很简单，区别就是后者使用了<code>mapper</code>。</p>
<p>在解释<code>mapper</code>是什么之前我们首先要知道的是，在<code>detectron2</code>中，一张图片对应的是一个<code>dict</code>，那么整个数据集就是<code>listdict</code>。之后我们再看<code>DatsetFromList</code>，它的<code>__getitem__</code>函数非常简单，它只是简单粗暴地就返回了指定idx的元素。显然这样是不行的，因为在把数据扔给模型训练之前我们肯定还要对数据做一定的处理，而这个工作就是由<code>mapper</code>来做的，默认情况下使用的是<code>detectron2/data/dataset_mapper.py</code>中定义的<code>DatasetMapper</code>，如果你需要自定义一个<code>mapper</code>也可以参考这个写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatasetMapper(cfg, is_train=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>我们继续了解一下<code>DatasetMapper</code>的实现原理，首先看一下官方给的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A callable which takes a dataset dict in Detectron2 Dataset format,</span></span><br><span class="line"><span class="string">and map it into a format used by the model.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>简单概括就是这个类是可调用的(callable),所以在下面的源码中可以看到定义了<code>__call__</code>方法。</p>
<p>该类主要做了这三件事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The callable currently does the following:</span><br><span class="line">1. Read the image from &quot;file_name&quot;</span><br><span class="line">2. Applies cropping/geometric transforms to the image and annotations</span><br><span class="line">3. Prepare data and annotations to Tensor and :class:`Instances`</span><br></pre></td></tr></table></figure>

<p>其源码如下（有删减）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatasetMapper</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cfg, is_train=True)</span>:</span></span><br><span class="line">  <span class="comment"># 读取cfg的参数</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, dataset_dict)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dict: a format that builtin models in detectron2 accept</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dataset_dict = copy.deepcopy(dataset_dict)  <span class="comment"># it will be modified by code below</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 1. 读取图像数据</span></span><br><span class="line">    image = utils.read_image(dataset_dict[<span class="string">"file_name"</span>], format=self.img_format)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 2. 对image和box等做Transformation</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"annotations"</span> <span class="keyword">not</span> <span class="keyword">in</span> dataset_dict:</span><br><span class="line">      image, transforms = T.apply_transform_gens(</span><br><span class="line">        ([self.crop_gen] <span class="keyword">if</span> self.crop_gen <span class="keyword">else</span> []) + self.tfm_gens, image</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    ...</span><br><span class="line">      image, transforms = T.apply_transform_gens(self.tfm_gens, image)</span><br><span class="line">      <span class="keyword">if</span> self.crop_gen:</span><br><span class="line">        transforms = crop_tfm + transforms</span><br><span class="line"></span><br><span class="line">      image_shape = image.shape[:<span class="number">2</span>]  <span class="comment"># h, w</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 3.将数据转化成tensor格式</span></span><br><span class="line">    dataset_dict[<span class="string">"image"</span>] = torch.as_tensor(image.transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).astype(<span class="string">"float32"</span>))</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataset_dict</span><br></pre></td></tr></table></figure>

<p><code>MapDataset</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapDataset</span><span class="params">(data.Dataset)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataset, map_func)</span>:</span></span><br><span class="line">    self._dataset = dataset</span><br><span class="line">    self._map_func = PicklableWrapper(map_func)  <span class="comment"># wrap so that a lambda will work</span></span><br><span class="line"></span><br><span class="line">    self._rng = random.Random(<span class="number">42</span>)</span><br><span class="line">    self._fallback_candidates = set(range(len(dataset)))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self._dataset)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">    retry_count = <span class="number">0</span></span><br><span class="line">    cur_idx = int(idx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      data = self._map_func(self._dataset[cur_idx])</span><br><span class="line">      <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._fallback_candidates.add(cur_idx)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># _map_func fails for this idx, use a random new index from the pool</span></span><br><span class="line">        retry_count += <span class="number">1</span></span><br><span class="line">        self._fallback_candidates.discard(cur_idx)</span><br><span class="line">        cur_idx = self._rng.sample(self._fallback_candidates, k=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> retry_count &gt;= <span class="number">3</span>:</span><br><span class="line">          logger = logging.getLogger(__name__)</span><br><span class="line">          logger.warning(</span><br><span class="line">            <span class="string">"Failed to apply `_map_func` for idx: &#123;&#125;, retry count: &#123;&#125;"</span>.format(</span><br><span class="line">              idx, retry_count</span><br><span class="line">            )</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>

<ul>
<li><code>self._fallback_candidates</code>是一个<code>set</code>,它的特点是其中的元素是独一无二的，定义这个的作用是记录可正常读取的数据索引，因为有的数据可能无法正常读取，所以这个时候我们就可以把这个坏数据的索引从<code>_fallback_candidates</code>中剔除，并随机采样一个索引来读取数据。</li>
<li><code>__getitem__</code>中的逻辑就是首先读取指定索引的数据，如果正常读取就把该所索引值加入到<code>_fallback_candidates</code>中去；反之，如果数据无法读取，则将对应索引值删除，并随机采样一个数据，并且尝试3次，若3次后都无法正常读取数据，则报错，但是好像也没有退出程序，而是继续读数据，可能是以为总有能正常读取的数据吧;</li>
</ul>
<h1 id="3-Debug"><a href="#3-Debug" class="headerlink" title="3. Debug"></a>3. Debug</h1><h2 id="3-1-Using-ground-py"><a href="#3-1-Using-ground-py" class="headerlink" title="3.1 Using ground.py"></a>3.1 Using ground.py</h2><h1 id="4-Training"><a href="#4-Training" class="headerlink" title="4. Training"></a>4. Training</h1><h2 id="4-1-在COCO数据集上训练"><a href="#4-1-在COCO数据集上训练" class="headerlink" title="4.1 在COCO数据集上训练"></a>4.1 在COCO数据集上训练</h2><p>Using 1 image per batch, cause the desktop can’t afford 2 images per batch.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python tools/train_net.py \</span><br><span class="line">	--config-file configs/COCO-Keypoints/keypoint_rcnn_R_50_FPN_1x.yaml \</span><br><span class="line">	SOLVER.IMS_PER_BATCH 1 SOLVER.BASE_LR 0.0025</span><br></pre></td></tr></table></figure>

<p>Training parameters:</p>
<ul>
<li>max_mem: 2638M;</li>
<li>89999 iterations;</li>
<li>The training log is saved to log_1127_first_training.txt;</li>
</ul>
<h2 id="4-2-训练流程"><a href="#4-2-训练流程" class="headerlink" title="4.2 训练流程"></a>4.2 训练流程</h2><p>主要训练函数为<code>tools/train_net.py</code>中的<code>main</code>函数，<code>launch</code>函数将训练过程分布化，在当前阶段暂时不予深究。</p>
<h1 id="5-Validation"><a href="#5-Validation" class="headerlink" title="5. Validation"></a>5. Validation</h1><p>python demo/demo.py <br>  –config-file configs/COCO-Keypoints/keypoint_rcnn_R_50_FPN_1x.yaml <br>  –input comunity/1574912817253.png <br>  –opts MODEL.WEIGHTS weights/COCO-Keypoints/model_final_04e291.pkl</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/16/CPP-Primer-Chapter-5-Statements/" rel="next" title="CPP Primer Chapter 5 Statements">
                  <i class="fa fa-chevron-left"></i> CPP Primer Chapter 5 Statements
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zepyhrus</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-代码结构概览"><span class="nav-number">1.</span> <span class="nav-text">1. 代码结构概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-代码逻辑分析"><span class="nav-number">2.</span> <span class="nav-text">2. 代码逻辑分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-超参数配置"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 超参数配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Trainer结构"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Trainer结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Trainer解析"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 Trainer解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-build-方法"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 build_*方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-注册机制Registry"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 注册机制Registry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Detectron2-整体代码框架"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 Detectron2 整体代码框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Dataset"><span class="nav-number">3.</span> <span class="nav-text">3. Dataset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-获取dataset-dicts"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 获取dataset_dicts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-解析成DatasetFromList"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 解析成DatasetFromList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-将DatasetFromList转化为MapDataset"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.3 将DatasetFromList转化为MapDataset</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Debug"><span class="nav-number">4.</span> <span class="nav-text">3. Debug</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Using-ground-py"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 Using ground.py</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Training"><span class="nav-number">5.</span> <span class="nav-text">4. Training</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-在COCO数据集上训练"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 在COCO数据集上训练</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-训练流程"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 训练流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Validation"><span class="nav-number">6.</span> <span class="nav-text">5. Validation</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zepyhrus</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
